#!/bin/bash

### renewcert Usage:help
# 
# Setup/renew a Let's Encrypt certificate
#
# Installs or updates the Let's Encrypt client from github, and runs it
# whilst logging the output of operations to a file, then restarts the
# associated service.
#
# USAGE
# =====
#
# 	renewcert [-s] DOMAIN
#
# Renew the cert for the specififed domain, for example
#
#     renewcert example.com
#
# The '-s' option silences the output ; useful for automation.
#
# ENVIRONMENT VARIABLES
# =====================
#
# The script uses a number of environment variables which you can
# change as suits you.
#
# LEDIR - the letsencrypt directory, by default this is "$HOME/letsencrypt"
#
# CERTLOG - the file to write logging information to. By default this is 
# 	/var/log/renewcert/certrenewal-$(date +"%F-%T").log
# 	Logging will occur even when in silent mode
#
# WEBSERVICE - the name of the system HTTP service to restart once the
# 	certificate renewal is complete. By defaut this is "apache2"
#
# 	Meaningful alternative values: nginx
#
# 	Any other value will be treated as apache2/httpd in letsencrypt;
# 	the value itself will be used as the service's name.
#
###/doc

#!/bin/bash

### printhelp Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `printhelp` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
###/doc

CHAR='#'

function printhelp {
	USAGESTRING=help
	TARGETFILE=$0
	if [[ -n "$*" ]]; then USAGESTRING="$1" ; shift; fi
	if [[ -n "$*" ]]; then TARGETFILE="$1" ; shift; fi

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$CHAR$CHAR$CHAR"'\s+(.+?)\s+Usage:'"$USAGESTRING"'\s*$'
        local SECEND='^\s*'"$CHAR$CHAR$CHAR"'\s*/doc\s*$'
        local insec="$(mktemp --tmpdir)"; rm "$insec"
        cat "$TARGETFILE" | while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        touch "$insec"
                        echo -e "${BASH_REMATCH[1]}\n---\n"
                elif [[ -f $insec ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                rm "$insec"
                        else
				echo "$secline" | sed -r "s/^\s*$CHAR//g"
                        fi
                fi
        done
        if [[ -f "$insec" ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
		rm "$insec"
        fi
	echo ""
}

### automatic help Usage:bbuild
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$@" =~ --help ]]; then
	printhelp
	exit 0
fi
#!/bin/bash

#!/bin/bash

export CDEF="[0m"
export CRED="[31m"
export CGRN="[32m"
export CYEL="[33m"
export CBLU="[34m"
export CBRED="[1;31m"
export CBGRN="[1;32m"
export CBYEL="[1;33m"
export CBBLU="[1;34m"

MODE_DEBUG=no

### debuge MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function debuge {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### infoe MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function infoe {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### warne MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function warne {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### faile MESSAGE CODE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function faile {
	local MSG=
	local ARG=
	local ERCODE=127
	local numpat='^[0-9]+$'
	while [[ -n "$*" ]]; do
		ARG=$1 ; shift
		if [[ -z "$*" ]] && [[ "$ARG" =~ $numpat ]]; then
			ERCODE=$ARG
		else
			MSG="$MSG $ARG"
		fi
	done
	echo "${CBRED}ERROR FAIL:$CRED$MSG$CDEF" 1>&2
	exit "$ERCODE"
}

function dumpe {
	echo -n "[1;35m$*" 1>&2
	echo -n "[0;35m" 1>&2
	cat - 1>&2
	echo -n "[0m" 1>&2
}

if [[ "$*" =~ --debug ]]; then
	MODE_DEBUG=yes
fi

if [[ -z "$*" ]]; then
	printhelp
	exit
fi

set -eu

# =================================
# Setup env vars

if [[ -z "${WEBSERVICE+x}" ]]; then
	WEBSERVICE="apache2"
fi

if [[ -z "${LEDIR+x}" ]]; then
	LEDIR="$HOME/letsencrypt"
fi

if [[ -z "${CERTLOG+x}" ]]; then
	CERTLOG=/var/log/renewcert/certrenewal-$(date +"%F-%T").log
fi

mkdir -p "$(dirname "$CERTLOG")"

# ==================================
# Domain detection / args reading

DOMAIN="$1" ; shift

if [[ "$DOMAIN" = -s ]]; then
	"$0" "$@" 2>&1 >/dev/null
	exit

elif [[ "$DOMAIN" = --debug ]]; then
	if [[ -z "${1+x}" ]]; then
		faile "Please specify a domain name to renew for."
	fi

	DOMAIN="$1" ; shift
fi


debuge "Web service:        $WEBSERVICE"
debuge "Let's Encrypt dir:  $LEDIR"
debuge "Cert renewal log:   $CERTLOG"
debuge "Domain to renew:    $DOMAIN"

# ===================================
# Install/update tooling

JUSTPULLED=no
if [[ ! -d "$LEDIR" ]]; then
	git clone https://github.com/letsencrypt/letsencrypt "$LEDIR" 2>&1 | tee -a "$CERTLOG"
	JUSTPULLED=yes
fi

cd "$LEDIR"
if [[ "$JUSTPULLED" != yes ]] && [[ -d .git ]]; then
	git pull 2>&1 | tee -a "$CERTLOG"
	JUSTPULLED=yes
fi

# ====================================
# Run the certificate update and restart apache

LEFLAG=--apache
if [[ "$WEBSERVICE" = nginx ]]; then
	LEFLAG=--nginx
fi

./letsencrypt-auto certonly "$LEFLAG" --renew-by-default -d "$DOMAIN" 2>&1 | tee -a "$CERTLOG"

if [[ -f /bin/systemctl ]] || [[ -f /usr/bin/systemctl ]]; then
	systemctl restart "$WEBSERVICE" 2>&1 | tee -a "$CERTLOG"

else
	service "$WEBSERVICE" restart 2>&1 | tee -a "$CERTLOG"
fi
