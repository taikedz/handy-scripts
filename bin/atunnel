#! /bin/bash

# Script to automatically start or kill a tunnel
# Saves information to a ~/.autotunnel/PORT.pid containing the PID of the SSH instance

# ssh -fN -R 5500:localhost:22 anchor & >> ~/.autotunnel/PORT.log

# Declare global variables

t_confdir=$HOME/.autotunnel
mkdir -p $t_confdir
if [[ $? != 0 ]]; then
	echo "Could not make preferences directory!"
	exit 1
fi

# DECLARE ARGS

t_action=
t_lport=
t_rport=
t_rserv=
t_ruser=
t_cport=

# =========================================
# Bash argument extraction example
# ===

function getarg {
	# $1 - arg
	# $2 - label
	# $3+ - value(s)
	local a_arg=$1
	shift

	local a_label=$1
	shift

	local a_match=$1
	shift

	echo "$a_arg" | grep -E "^$a_label=$a_match$" | sed -e "s/$a_label=//"
}

function matcharg {
	# $1 - argument
	# $2+ - values
	local a_arg=$1
	shift

	local a_match=$( echo "$@" | tr ',' '\n' )

	echo -e "$a_match" | grep "^$a_arg$"
}

function argextract {
	#$1 - argument
	#$2 - series of capturing patterns captured sequentially
	# This is a bit kludgy and needs refining
	
	local a_arg=$1
	shift
	
	#echo "Arg $a_arg"

	local var
	for var in "$@"; do
		#echo "Pat $var"
		a_arg=$(echo $a_arg | sed -r "s|^$var$|\1|")
	done
	echo $a_arg
}

# ===== Usage

for var in "$@"; do
	if [[ $( matcharg "$var" "--help,-h,/h" ) != "" ]]; then
		cat <<EOHELP
$0 - Open a remote tunnel

Assuming you can tunnel to a remote server, this script is intended to take care of the logic of testing and managing a remote tunnel connection

== Usage ==

$0 ACTION --lport=LPORT [--rport=RPORT --server=SERVER --user=USER --cport=CPORT]

$0 START --ssh=USER@SERVER:CPORT --tunnel=RPORT-LPORT

	ACTION - any of "START", "STOP" or "STATUS" ; only ACTION requires the full set of arguments

	LPORT - the local port you want to forward the tunnel to

STOP and STATUS only need the local port number to stop the tunnel, if it exists

Establishing a connection with START requires these additional parameters

	RPORT - the port on the remote server which is listening

	SERVER - the remote server which is the front end of the tunnel

	USER - the user on the remote server

	CPORT - the SSH port of the remote server

EOHELP
		exit 0
	fi
	
	l_action=$( matcharg "$var" "START,STOP,STATUS"  )
	if [[ x$l_action != x ]]; then t_action=$l_action; fi

	# Shorthand for the ports: --tunnel=rport-lport
	l_ports=$( getarg "$var" "--tunnel" "[1-9][0-9]+-[1-9][0-9]+" )
	if [[ x$l_ports != x ]]; then
		t_rport=$( argextract "$l_ports" ".*-([1-9][0-9]+)" )
		t_lport=$( argextract "$l_ports" "([1-9][0-9]+)-.*" )
	fi

	l_lport=$( getarg "$var" "--lport" "[1-9][0-9]+"  )
	if [[ x$l_lport != x ]]; then t_lport=$l_lport; fi

	l_rport=$( getarg "$var" "--rport" "[1-9][0-9]+" )
	if [[ x$l_rport != x ]]; then t_rport=$l_rport; fi

	# Here's a shorthand: --ssh=user@server:port part
	l_ssh=$( getarg "$var" "--ssh" "[a-zA-Z0-9_-]+@[^.][a-z0-9\\.-]+[^.]:[1-9][0-9]+" )
	if [[ x$l_ssh != x ]]; then
		# old man in care home complaining about the eggs
		# they taste of nothing. nothing. nothing.
		# nurse replies "I just cooked the eggs - I don't lay them"
		t_ruser=$( argextract "$l_ssh" "([a-zA-Z0-9_-]+)@.*" )
		t_rserv=$( argextract "$l_ssh" ".*@([^.][a-z0-9\\.-]+[^.]):.*" )
		t_cport=$( argextract "$l_ssh" ".*:([1-9][0-9]+)" )
	fi
	
	l_rserv=$( getarg "$var" "--server" "[^.][a-z0-9\\.-]+[^.]" )
	if [[ x$l_rserv != x ]]; then t_rserv=$l_rserv; fi

	l_ruser=$( getarg "$var" "--user" "[a-zA-Z0-9_-]+" )
	if [[ x$l_ruser != x ]]; then t_ruser=$l_ruser; fi

	l_cport=$( getarg "$var" "--cport" "[1-9][0-9]+" )
        if [[ x$l_cport != x ]]; then t_cport=$l_cport; fi
done

# ===
# Argument processing is done
# ================================

cat <<EOF
Action: $t_action

Local port: $t_lport
Remote port: $t_rport

Server: $t_rserv
Remote user: $t_ruser
Connection port: $t_cport
EOF

# ============
# This section is not at all robust...
# Need to be able to find connections we did not initiate
# Need to be able to kill off processes reliably, or reliably report failure to kill them
# Probably also be able to manage tunnels by name

case $t_action in
START)
	if [[ ! -f "$t_confdir/$t_lport.log" ]]; then
		# TODO - Somehow we have to pass the password
		# which is probbaly not possible if programatically, so need to pass
		# a key file
		ssh -fN -R "$t_lport:localhost:$t_rport" "$t_ruser@$t_rserv" -p $t_cport >> "$t_confdir/$t_lport.log" # remember to match the below next!
		pidline=$( ps aux | grep "$t_lport:localhost:$t_rport $t_ruser@$t_rserv" | grep -v grep )
		# extract PID
		pid=$( echo $pidline | sed -r "s|^$USER\\s+([0-9]+)\\s+.+$|\1|" )
		echo -e "$pid\n$pidline" > "$t_confdir/$t_lport.log"
	else
                echo -n "There is a tunnel running for port $t_lport: "
                tail -n 1 "$t_confdir/$t_lport.log"
	fi
	;;
STOP)
	kill $( echo "$t_confdir/$t_lport.log" | head -n 1 )
	mv "$t_confdir/$t_lport.log" "$t_confdir/$t_lport-killed.log"
	;;
STATUS)
	if [[ -f "$t_confdir/$t_lport.log" ]]; then
		echo -n "There is a tunnel running for port $t_lport: "
		tail -n 1 "$t_confdir/$t_lport.log"
	else
		echo "No active tunnel found running for port $t_lport."
	fi
esac
